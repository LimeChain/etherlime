"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:calldata");
const read_1 = __importDefault(require("../read"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const value_1 = __importDefault(require("./value"));
const calldata_1 = require("../allocate/calldata");
const lodash_range_1 = __importDefault(require("lodash.range"));
function decodeCalldata(definition, pointer, info, base = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        if (DecodeUtils.Definition.isReference(definition)) {
            let dynamic = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations)[1];
            if (dynamic) {
                return yield decodeCalldataReferenceByAddress(definition, pointer, info, base);
            }
            else {
                return yield decodeCalldataReferenceStatic(definition, pointer, info);
            }
        }
        else {
            debug("pointer %o", pointer);
            return yield value_1.default(definition, pointer, info);
        }
    });
}
exports.default = decodeCalldata;
function decodeCalldataReferenceByAddress(definition, pointer, info, base = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const { state } = info;
        debug("pointer %o", pointer);
        let rawValue = yield read_1.default(pointer, state);
        let startPosition = DecodeUtils.Conversion.toBN(rawValue).toNumber() + base;
        debug("startPosition %d", startPosition);
        let [size, dynamic] = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations);
        if (!dynamic) { //this will only come up when called from stack.ts
            let staticPointer = {
                calldata: {
                    start: startPosition,
                    length: size
                }
            };
            return yield decodeCalldataReferenceStatic(definition, staticPointer, info);
        }
        let length;
        switch (DecodeUtils.Definition.typeClass(definition)) {
            case "bytes":
            case "string":
                length = DecodeUtils.Conversion.toBN(yield read_1.default({
                    calldata: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE }
                }, state)).toNumber(); //initial word contains length
                let childPointer = {
                    calldata: { start: startPosition + DecodeUtils.EVM.WORD_SIZE, length }
                };
                return yield value_1.default(definition, childPointer, info);
            case "array":
                if (DecodeUtils.Definition.isDynamicArray(definition)) {
                    length = DecodeUtils.Conversion.toBN(yield read_1.default({
                        calldata: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE },
                    }, state)).toNumber(); // initial word contains array length
                    startPosition += DecodeUtils.EVM.WORD_SIZE; //increment startPosition to
                    //next word, as first word was used for length
                }
                else {
                    length = DecodeUtils.Definition.staticLength(definition);
                }
                //note: I've written this fairly generically, but it is worth noting that
                //since this array is of dynamic type, we know that if it's static length
                //then size must be EVM.WORD_SIZE
                let baseDefinition = definition.baseType || definition.typeName.baseType;
                //I'm deliberately not using the DecodeUtils function for this, because
                //we should *not* need a faked-up type here!
                // replace erroneous `_storage_` type identifiers with `_calldata_`
                baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "calldata");
                let baseSize = calldata_1.calldataSize(baseDefinition, info.referenceDeclarations, info.calldataAllocations)[0];
                return yield Promise.all(lodash_range_1.default(length).map((index) => decodeCalldata(baseDefinition, { calldata: {
                        start: startPosition + index * baseSize,
                        length: baseSize
                    } }, info, startPosition) //pointer base is always start of list, never the length
                ));
            case "struct":
                const { referenceDeclarations, calldataAllocations } = info;
                const referencedDeclaration = definition.typeName
                    ? definition.typeName.referencedDeclaration
                    : definition.referencedDeclaration;
                const structAllocation = calldataAllocations[referencedDeclaration];
                if (structAllocation == null) {
                    return undefined; //this should never happen
                }
                const decodeAllocation = (memberAllocation) => __awaiter(this, void 0, void 0, function* () {
                    const memberPointer = memberAllocation.pointer;
                    const childPointer = {
                        calldata: {
                            start: startPosition + memberPointer.calldata.start,
                            length: memberPointer.calldata.length
                        }
                    };
                    let memberDefinition = memberAllocation.definition;
                    // replace erroneous `_storage` type identifiers with `_calldata`
                    memberDefinition = DecodeUtils.Definition.spliceLocation(memberDefinition, "calldata");
                    //there also used to be code here to add on the "_ptr" ending when absent, but we
                    //presently ignore that ending, so we'll skip that
                    let decoded = yield decodeCalldata(memberDefinition, childPointer, info, startPosition);
                    //note in this case startPosition has not been altered,
                    //which is how we want it
                    return {
                        [memberDefinition.name]: decoded
                    };
                });
                const decodings = Object.values(structAllocation.members).map(decodeAllocation);
                return Object.assign({}, ...yield Promise.all(decodings));
            default:
                // debug("Unknown calldata reference type: %s", DecodeUtils.typeIdentifier(definition));
                return undefined;
        }
    });
}
exports.decodeCalldataReferenceByAddress = decodeCalldataReferenceByAddress;
function decodeCalldataReferenceStatic(definition, pointer, info) {
    return __awaiter(this, void 0, void 0, function* () {
        const { state } = info;
        debug("static");
        debug("pointer %o", pointer);
        switch (DecodeUtils.Definition.typeClass(definition)) {
            case "array":
                //we're in the static case, so we know the array must be statically sized
                const length = DecodeUtils.Definition.staticLength(definition);
                let size = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations)[0];
                let baseDefinition = definition.baseType || definition.typeName.baseType;
                //I'm deliberately not using the DecodeUtils function for this, because
                //we should *not* need a faked-up type here!
                // replace erroneous `_storage_` type identifiers with `_calldata_`
                baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "calldata");
                let baseSize = calldata_1.calldataSize(baseDefinition, info.referenceDeclarations, info.calldataAllocations)[0];
                return yield Promise.all(lodash_range_1.default(length).map((index) => decodeCalldata(baseDefinition, { calldata: {
                        start: pointer.calldata.start + index * baseSize,
                        length: baseSize
                    } }, info) //static case so don't need base
                ));
            case "struct":
                //this one is exactly the same as in the dynamic case,
                //except that we don't need to pass base to decodeCalldata
                //(or in other words, COPYPASTE WARNING; sorry future me :P )
                const { referenceDeclarations, calldataAllocations } = info;
                const referencedDeclaration = definition.typeName
                    ? definition.typeName.referencedDeclaration
                    : definition.referencedDeclaration;
                const structAllocation = calldataAllocations[referencedDeclaration];
                if (structAllocation == null) {
                    return undefined; //this should never happen
                }
                const decodeAllocation = (memberAllocation) => __awaiter(this, void 0, void 0, function* () {
                    const memberPointer = memberAllocation.pointer;
                    const childPointer = {
                        calldata: {
                            start: pointer.calldata.start + memberPointer.calldata.start,
                            length: memberPointer.calldata.length
                        }
                    };
                    let memberDefinition = memberAllocation.definition;
                    // replace erroneous `_storage` type identifiers with `_calldata`
                    memberDefinition = DecodeUtils.Definition.spliceLocation(memberDefinition, "calldata");
                    //there also used to be code here to add on the "_ptr" ending when absent, but we
                    //presently ignore that ending, so we'll skip that
                    let decoded = yield decodeCalldata(memberDefinition, childPointer, info);
                    return {
                        [memberDefinition.name]: decoded
                    };
                });
                const decodings = Object.values(structAllocation.members).map(decodeAllocation);
                return Object.assign({}, ...yield Promise.all(decodings));
            default:
                // debug("Unknown calldata reference type: %s", DecodeUtils.typeIdentifier(definition));
                return undefined;
        }
    });
}
exports.decodeCalldataReferenceStatic = decodeCalldataReferenceStatic;
//# sourceMappingURL=calldata.js.map