"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _nodeHid = require("node-hid");

var _nodeHid2 = _interopRequireDefault(_nodeHid);

var _hwTransport = require("@ledgerhq/hw-transport");

var _hwTransport2 = _interopRequireDefault(_hwTransport);

var _hidFraming = require("@ledgerhq/devices/lib/hid-framing");

var _hidFraming2 = _interopRequireDefault(_hidFraming);

var _devices = require("@ledgerhq/devices");

var _errors = require("@ledgerhq/errors");

var _getDevices = require("./getDevices");

var _getDevices2 = _interopRequireDefault(_getDevices);

var _listenDevices2 = require("./listenDevices");

var _listenDevices3 = _interopRequireDefault(_listenDevices2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var listenDevicesDebounce = 500;
var listenDevicesPollingSkip = function listenDevicesPollingSkip() {
  return false;
};
var listenDevicesDebug = function listenDevicesDebug() {};

var isDisconnectedError = function isDisconnectedError(e) {
  return e && e.message && e.message.indexOf("HID") >= 0;
};

/**
 * node-hid Transport implementation
 * @example
 * import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
 * ...
 * TransportNodeHid.create().then(transport => ...)
 */

var TransportNodeHid = function (_Transport) {
  _inherits(TransportNodeHid, _Transport);

  _createClass(TransportNodeHid, null, [{
    key: "open",


    /**
     * if path="" is not provided, the library will take the first device
     */


    /**
     *
     */


    /**
     *
     */

    /**
     *
     */
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(path) {
        var device;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!path) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", Promise.resolve(new TransportNodeHid(new _nodeHid2.default.HID(path))));

              case 2:
                device = (0, _getDevices2.default)()[0];

                if (device) {
                  _context.next = 5;
                  break;
                }

                throw new _errors.TransportError("NoDevice", "NoDevice");

              case 5:
                return _context.abrupt("return", Promise.resolve(new TransportNodeHid(new _nodeHid2.default.HID(device.path))));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function open(_x) {
        return _ref.apply(this, arguments);
      }

      return open;
    }()

    /**
     */


    /**
     *
     */


    /**
     *
     */

  }]);

  function TransportNodeHid(device) {
    _classCallCheck(this, TransportNodeHid);

    var _this = _possibleConstructorReturn(this, (TransportNodeHid.__proto__ || Object.getPrototypeOf(TransportNodeHid)).call(this));

    _initialiseProps.call(_this);

    _this.device = device;
    // $FlowFixMe
    var info = device.getDeviceInfo();
    _this.deviceModel = info && info.serialNumber ? (0, _devices.identifyUSBProductId)(parseInt(info.serialNumber, 16)) : null;
    return _this;
  }

  /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */


  _createClass(TransportNodeHid, [{
    key: "setScrambleKey",
    value: function setScrambleKey() {}

    /**
     * release the USB device.
     */

  }, {
    key: "close",
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.exchangeBusyPromise;

              case 2:
                this.device.close();

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function close() {
        return _ref2.apply(this, arguments);
      }

      return close;
    }()
  }]);

  return TransportNodeHid;
}(_hwTransport2.default);

TransportNodeHid.isSupported = function () {
  return Promise.resolve(typeof _nodeHid2.default.HID === "function");
};

TransportNodeHid.list = function () {
  return Promise.resolve((0, _getDevices2.default)().map(function (d) {
    return d.path;
  }));
};

TransportNodeHid.setListenDevicesDebounce = function (delay) {
  listenDevicesDebounce = delay;
};

TransportNodeHid.setListenDevicesPollingSkip = function (conditionToSkip) {
  listenDevicesPollingSkip = conditionToSkip;
};

TransportNodeHid.setListenDevicesDebug = function (debug) {
  listenDevicesDebug = typeof debug === "function" ? debug : debug ? function () {
    var _console;

    for (var _len = arguments.length, log = Array(_len), _key = 0; _key < _len; _key++) {
      log[_key] = arguments[_key];
    }

    return (_console = console).log.apply(_console, ["[listenDevices]"].concat(log));
  } : function () {};
};

TransportNodeHid.listen = function (observer) {
  var unsubscribed = false;
  Promise.resolve((0, _getDevices2.default)()).then(function (devices) {
    // this needs to run asynchronously so the subscription is defined during this phase
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = devices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var device = _step.value;

        if (!unsubscribed) {
          var descriptor = device.path;
          var deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
          observer.next({ type: "add", descriptor: descriptor, device: device, deviceModel: deviceModel });
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  var _listenDevices = (0, _listenDevices3.default)(listenDevicesDebounce, listenDevicesPollingSkip, listenDevicesDebug),
      events = _listenDevices.events,
      stop = _listenDevices.stop;

  var onAdd = function onAdd(device) {
    if (unsubscribed || !device) return;
    var deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
    observer.next({
      type: "add",
      descriptor: device.path,
      deviceModel: deviceModel,
      device: device
    });
  };
  var onRemove = function onRemove(device) {
    if (unsubscribed || !device) return;
    var deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
    observer.next({
      type: "remove",
      descriptor: device.path,
      deviceModel: deviceModel,
      device: device
    });
  };
  events.on("add", onAdd);
  events.on("remove", onRemove);
  function unsubscribe() {
    unsubscribed = true;
    events.removeListener("add", onAdd);
    events.removeListener("remove", onRemove);
    stop();
  }
  return { unsubscribe: unsubscribe };
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.channel = Math.floor(Math.random() * 0xffff);
  this.packetSize = 64;
  this.disconnected = false;

  this.setDisconnected = function () {
    if (!_this2.disconnected) {
      _this2.emit("disconnect");
      _this2.disconnected = true;
    }
  };

  this.writeHID = function (content) {
    var data = [0x00];
    for (var i = 0; i < content.length; i++) {
      data.push(content[i]);
    }
    try {
      _this2.device.write(data);
      return Promise.resolve();
    } catch (e) {
      if (isDisconnectedError(e)) {
        _this2.setDisconnected();
        return Promise.reject(new _errors.DisconnectedDevice(e.message));
      }
      return Promise.reject(e);
    }
  };

  this.readHID = function () {
    return new Promise(function (resolve, reject) {
      return _this2.device.read(function (e, res) {
        if (!res) {
          return reject(new _errors.DisconnectedDevice());
        }
        if (e) {
          if (isDisconnectedError(e)) {
            _this2.setDisconnected();
            return reject(new _errors.DisconnectedDevice(e.message));
          }
          reject(e);
        } else {
          var buffer = Buffer.from(res);
          resolve(buffer);
        }
      });
    });
  };

  this.exchange = function (apdu) {
    return _this2.exchangeAtomicImpl(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var debug, channel, packetSize, framing, blocks, i, result, acc, buffer;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              debug = _this2.debug, channel = _this2.channel, packetSize = _this2.packetSize;

              if (debug) {
                debug("=>" + apdu.toString("hex"));
              }

              framing = (0, _hidFraming2.default)(channel, packetSize);

              // Write...

              blocks = framing.makeBlocks(apdu);
              i = 0;

            case 5:
              if (!(i < blocks.length)) {
                _context3.next = 11;
                break;
              }

              _context3.next = 8;
              return _this2.writeHID(blocks[i]);

            case 8:
              i++;
              _context3.next = 5;
              break;

            case 11:

              // Read...
              result = void 0;
              acc = void 0;

            case 13:
              if (result = framing.getReducedResult(acc)) {
                _context3.next = 20;
                break;
              }

              _context3.next = 16;
              return _this2.readHID();

            case 16:
              buffer = _context3.sent;

              acc = framing.reduceResponse(acc, buffer);
              _context3.next = 13;
              break;

            case 20:

              if (debug) {
                debug("<=" + result.toString("hex"));
              }
              return _context3.abrupt("return", result);

            case 22:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, _this2);
    })));
  };
};

exports.default = TransportNodeHid;
//# sourceMappingURL=TransportNodeHid.js.map